package kafka

import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/csye7125-su24-team05/webapp-cve-consumer/internal/helper"
	"github.com/segmentio/kafka-go"
	"github.com/segmentio/kafka-go/sasl/plain"
)

type Kafka interface {
	FetchMessage() (kafka.Message, error)
	CommitMessages(messages ...kafka.Message) error
	Close()
	CheckConnection() error
}

type kafkaReader struct {
	Dialer *kafka.Dialer
	Reader *kafka.Reader
	ctx context.Context
}

func NewKafka() Kafka {
	topic := helper.GetEnv("KAFKA_TOPIC", "")
	groupID := helper.GetEnv("KAFKA_GROUP_ID", "")
	broker := helper.GetEnv("KAFKA_BROKER", "")
	mechanism := plain.Mechanism{
		Username: helper.GetEnv("KAFKA_USERNAME", ""),
		Password: helper.GetEnv("KAFKA_PASSWORD", ""),
	}

	dialer := &kafka.Dialer{
		SASLMechanism: mechanism,
	}

	expoTimer := helper.NewExpoTimer(60)

	kafkaReader := &kafkaReader{
		Dialer: dialer,
		Reader: kafka.NewReader(kafka.ReaderConfig{
			Brokers: strings.Split(broker, ";"),
			Topic:   topic,
			GroupID: groupID,
			Dialer:  dialer,
			WatchPartitionChanges: true,
		}),
		ctx: context.Background(),
	}

	for {
		err := kafkaReader.CheckConnection()
		if err != nil {
			log.Printf("error checking connection to kafka: %v", err.Error())
			expoTimer.Sleep()
			continue
		}
		break
	}

	return kafkaReader
}

func (k *kafkaReader) Close() {
	if err := k.Reader.Close(); err != nil {
		log.Fatalf("error closing kafka reader: %v", err.Error())
	}
}

func (k *kafkaReader) FetchMessage() (kafka.Message, error) {
	message, err := k.Reader.FetchMessage(k.ctx)
	if err != nil {
		log.Printf("error fetching message from kafka: %v", err.Error())
		return kafka.Message{}, err
	}
	return message, nil
}

func (k *kafkaReader) CommitMessages(messages ...kafka.Message) error {
	err := k.Reader.CommitMessages(k.ctx, messages...)
	if err != nil {
		log.Printf("error committing messages to kafka: %v", err.Error())
		return err
	}
	return nil
}

func (k *kafkaReader) CheckConnection() error {
	totalConnectedBrokers := 0
	totalMatchedTopics := 0
	for _, broker := range k.Reader.Config().Brokers {
		conn, err := k.Dialer.DialContext(k.ctx, "tcp", broker)
		if err != nil {
			log.Printf("error connecting to broker %s: %v", broker, err.Error())
		} else {
			totalConnectedBrokers++
			partition, err := conn.ReadPartitions()
			if err != nil {
				log.Printf("error reading partitions from broker %s: %v", broker, err.Error())
			} else {
				for _, p := range partition {
					if p.Topic == k.Reader.Config().Topic {
						totalMatchedTopics++
					}
				}
			}
			conn.Close()
		}
	}
	if totalConnectedBrokers == 0 {
		return fmt.Errorf("no brokers connected")
	}
	if totalMatchedTopics == 0 {
		return fmt.Errorf("no topics matched")
	}
	return nil
}